import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as a,b as i}from"./app.8a378504.js";const l={},s=i('<h1 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> Hooks</h1><p>React的核心是组件，v16.8之前,组件的标准写法是class(类组件)</p><p><strong>类组件存在的问题：</strong></p><ol><li>代码很重（遇到简单的页面）</li><li>每创建一个类组件都要继承React实例</li></ol><p><strong>函数式组件存在的问题：</strong></p><ol><li>纯函数没有状态</li><li>纯函数没有生命周期</li><li>纯函数没有this</li><li>只能是纯函数</li></ol><p>类组件功能齐全，但是代码很重，纯函数组件很轻便却有很多限制，只能做UI展示，为了解决这个问题react 团队设计了react hooks</p><p>组件尽量写写成纯函数，如果需要外部的数据或者是功能，就准备一把钩子，把涉及到数据或者是功能的代码钩进纯函数组件里边</p><h2 id="_1-usestate-它的作用就是声明状态变量" tabindex="-1"><a class="header-anchor" href="#_1-usestate-它的作用就是声明状态变量" aria-hidden="true">#</a> 1.useState 它的作用就是声明状态变量</h2><p>useState 注意点：</p><ol><li><p>初始参数只在组件的首次渲染的时候使用，再次更新是会被忽略</p></li><li><p>每次通过setXxx 修改状态都会引起组件重新渲染</p></li><li><p>useState可以调用多次，每次都是独立的</p></li><li><p><code>useState只可以在函数组件之内使用</code></p></li><li><p>如果初始值需要计算才能得到，可以使用回调函数的形式来确定初始值</p></li><li><p>useEffect 可以为react组件完成副作用的操作</p></li></ol><p>react中，一个纯函数式组件主要的功能是通过数据渲染UI，剩余的其他的操作都是副作用</p><ol><li>ajax请求</li><li>手动DOM</li><li>本地存储</li></ol><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect" aria-hidden="true">#</a> useEffect</h2><p>useEffect 是在react更新DOM之后运行一些额外的代码，也就是执行副作用操作</p><p>依赖项执行机制:</p><ol><li>默认状态：首次执行+每次组件更新都执行 useEffect（）函数</li><li>添加了一个空的：[] 首次渲染的时候执行，执行一次useEffect（）函数</li><li>添加特定的依赖项的：首次执行 + 依赖项发生更新的时候执行useEffect（）函数</li></ol><h2 id="usecontext" tabindex="-1"><a class="header-anchor" href="#usecontext" aria-hidden="true">#</a> useContext</h2><p>帮助我们跨组件直接通信</p><p>使用步骤：</p><ol><li>使用creatContext创建context对象</li><li>在顶层组件通过Provider提供数据</li><li>底层组件通过useContext(context)函数去获取数据</li></ol><h2 id="useref" tabindex="-1"><a class="header-anchor" href="#useref" aria-hidden="true">#</a> useRef</h2><p>主要功能是帮助我们获取DOM元素或者组件，还可以保存值</p><ol><li>引入useRef,调用useRef()</li><li>通过ref属性将useRef的返回值绑定到元素身上</li><li>useRef()返回的是一个对象，对象内有一个current属性</li></ol><h2 id="usereducer" tabindex="-1"><a class="header-anchor" href="#usereducer" aria-hidden="true">#</a> useReducer</h2><p>useReducer是一个高级Hook,(useState,useEffect,useRef必须的hook)</p><p>useState是提供组件状态的，useReducer是useState升级版，所有的useState规则，useReducer都适用</p><p><strong>useReducer的使用步骤：</strong></p><ol><li>定义一个initState</li><li>定义一个reducerh函数，把所有的操作方法都放到这个函数里边</li><li>把initState跟reducer，通过的是useReducer关联起来，返回一个当前的state 和dispatch</li><li>当需要计算的时候，使用dispatch传递一个action值，触发的reducer函数，返回一个新的state</li></ol><p>useReducer的数据不共享，共享了reducer函数 rudex</p><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback" aria-hidden="true">#</a> useCallback</h2><p>解决的是重复渲染的问题，就是性能优化相关</p><p>useCallback起到了一个缓存的作用，即便父组件重新渲染了，useCallback包裹的函数不会重新生成，会返回上一次函数的引用</p>',33),r=[s];function c(o,u){return t(),a("div",null,r)}const p=e(l,[["render",c],["__file","6hooks.html.vue"]]);export{p as default};
