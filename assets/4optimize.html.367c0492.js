import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,b as e}from"./app.8a378504.js";const t={},p=e(`<h1 id="组件优化" tabindex="-1"><a class="header-anchor" href="#组件优化" aria-hidden="true">#</a> 组件优化</h1><ol><li>重复渲染问题 <ol><li>当组件的<code>props</code>或<code>state</code>发生变化时，React会构建新的<code>virtual DOM</code>（虚拟DOM），</li><li>然后通过diff算法把新旧的virtual DOM进行比较，如果新旧virtual DOM树<code>不等则会重新渲染</code>，否则不重新渲染。</li><li>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM</li><li>由于DOM操作的非常耗时的，因此要提高组件的性能就应该尽可能地减少组件的重新渲染。如果某个props或state改变了并不影响组件的渲染，那么这个时候是不需要重新渲染组件的。</li><li>但组件组合存在的问题，父组件的state或prop更新时，<code>无论子组件的state、prop是否更新，都会触发子组件的更新，这会形成很多没必要的render</code>，浪费很多性能。</li></ol></li></ol><p><strong>解决方案：</strong></p><ol><li><code>shouldComponentUpdate</code>钩子函数会在组件的重新渲染之前调用，返回<code>true</code>则重新渲染</li></ol><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token comment">/* 
  最新的props和最新的state，根据最新的props和state来判断是否需要调用 render()方法
  nextProps: 表示下一个props(最新的props)
  nextState: 表示下一个state的值（最新的state）
*/</span>
<span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 比较新旧props，决定是否重新渲染组件 不相等 会重新渲染</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>num <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>创建类时继承<code>PureComponent</code> , 函数组件用<code>memo</code></li></ol><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> PureComponent<span class="token punctuation">,</span>memo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandSon</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token comment">// 父组件 函数式组件 memo是一个高阶组件</span>
<span class="token keyword">const</span> Father <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;父组件被渲染了&#39;</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理：</strong> 浅比较 props和state进行浅比较 （shallowEqual）来实现的shouldComponentUpdate，不会进行深层次的比较，只比较外层数据结构，只要外层相同，则认为没有变化</p><p><strong>PureComponent存在的问题：</strong></p><ol><li>函数式组件不可以用(memo)</li><li>由于页面进行的浅比较，可能由于深层数据的不一致导致而产生错误判断，从而导致页面的不更新</li><li>正是因为进行的浅比较，所以不合适在多层次的嵌套对象</li></ol><h2 id="_2-setstate是同步的还是异步的" tabindex="-1"><a class="header-anchor" href="#_2-setstate是同步的还是异步的" aria-hidden="true">#</a> 2. setState是同步的还是异步的</h2><p>react18之前：</p><ol><li><p>在合成事件中是异步的，在生命周期钩子中是异步的</p></li><li><p>react17 在原生事件、在定时器中，是同步的</p></li></ol><p>合成事件：就是React内部自己实现了一套事件处理机制，不是原生的事件</p><p>每更新state就执行一次render(同步)</p><p>全部更新完毕以后执行一次render (异步)</p><p>批量更新，React将多次state更新进行合并处理，最终只进行一次渲染</p><p>react18之前手动批量更新</p><p>react18 自动批量更新, react的更新机制进行了变化，不再依赖于批量更新的标志</p>`,19),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","4optimize.html.vue"]]);export{d as default};
