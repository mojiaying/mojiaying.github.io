import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as p,a as l,b as s,d as e,f as t,r as n}from"./app.76aaae20.js";const c={},u=l("h1",{id:"高级问题-理论原理",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#高级问题-理论原理","aria-hidden":"true"},"#"),s(" 高级问题（理论原理）")],-1),d=l("ol",null,[l("li",null,"输入url发生了什么？")],-1),m={class:"custom-container details"},h=l("summary",null,"Details",-1),_=l("li",null,[s("浏览器查找域名的IP地址 "),l("ol",null,[l("li",null,"查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间,如果有缓存，直接返回IP，否则下一步"),l("li",null,"查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用(windows中是gethostbyname)，查找本机的hosts文件，如果找到，直接返回IP，否则下一步"),l("li",null,"查找路由器缓存：如果1，2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP服务商缓存的DNS的服务器，如果查找到IP则直接返回，没有的话继续查找"),l("li",null,"?递归查询：如果上述步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发送查询请求报文，而不是让该主机自己进行下一步查询。(本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的)"),l("li",null,"?迭代查询：本地域名服务器采用迭代查询，他先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地服务器下一步查询哪一个域名服务器，然后本地域名服务器进行后续的查询。（而不是替代本地域名服务器进行后续查询）")])],-1),g=l("li",null,"浏览器与目标服务器建立TCP连接:主机浏览器通过DNS解析得到了目标服务器的IP地址后，TCP与服务器三次握手建立连接",-1),y=l("li",null,"浏览器给web服务器发送一个HTTP请求",-1),T=l("li",null,"对于大型网站存在多个主机站点，负载均衡或者导入流量，提高SEO排名。往往不会直接返回请求页面，而是重定向。返回的状态码不是200ok，而是301，302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。",-1),k={href:"http://xn--baidu-r41h012u.com",target:"_blank",rel:"noopener noreferrer"},v=t("<li>浏览器跟踪重定向地址:当浏览器知道了重定向后最终的访问地址之后，重新发送一个http请求，发送内容同上。</li><li>服务器处理请求</li><li>服务器发出一个HTML响应</li><li>释放TCP连接 <ol><li>浏览器所在的主机向服务器发出连接释放报文，然后停止发送数据</li><li>服务器接收到释放连接报文后发出确认报文，然后将服务器上未传送完的数据发送完</li><li>服务器数据传输完毕后，向客户机发送连接释放报文</li><li>客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接</li></ol></li><li>浏览器显示页面:在浏览器没有完整接收全部HTML文档时，它就已经开始显示这个页面了，浏览器收到返回的数据包，根据浏览器的渲染机制对响应的数据进行渲染。渲染后的数据，进行相应的页面呈现和脚步的交互</li><li>浏览器发送获取嵌入在HTML中的其他内容 比如一些样式文件，图片url，js文件url等，浏览器会通过这些url重新发送请求，请求过程依然是HTML读取类似的过程，查询域名，发送请求，重定向等。不过这些静态文件是可以缓存到浏览器中的，有时访问这些文件不需要通过服务器，直接从缓存中取。某些网站也会使用第三方CDN进行托管这些静态文件。</li>",6),S=t(`<ol start="2"><li>页面渲染过程</li></ol><details class="custom-container details"><summary>Details</summary><p>浏览器将域名通过网络通信从服务器拿到html文件后</p><ol><li>根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。</li><li>构建渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。 构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上</li><li>页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。</li></ol><p><strong>何时回引起重排？</strong></p><p>当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：</p><p>1.添加或者删除可见的DOM元素；</p><p>2.元素位置改变——display、float、position、overflow等等；</p><p>3.元素尺寸改变——边距、填充、边框、宽度和高度；</p><p>4.内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p><p>5.页面渲染初始化；</p><p>6.浏览器窗口尺寸改变——resize事件发生时。</p><p><strong>如何减少和避免重排</strong></p><p>Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。</p><p>在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。----浏览器的渲染原理简介</p><ol><li><p>直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）；</p></li><li><p>让要操作的元素进行”离线处理”，处理完后一起更新；</p></li></ol><p>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；</p><p>b) 使用display:none技术，只引发两次回流和重绘；</p><p>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p><ol start="3"><li><p>不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存；</p></li><li><p>让元素脱离动流，减少回流的Render Tree的规模。</p></li></ol><p><strong>有以下几点可以优化渲染效率</strong></p><ol><li><p>合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型；</p></li><li><p>样式文件应当在 head 标签中，而脚本文件在 body 结束前，这样可以防止阻塞的方式；</p></li><li><p>简化并优化CSS选择器，尽量将嵌套层减少到最小；</p></li><li><p>尽量减少在 JavaScript 中进行DOM操作；</p></li><li><p>修改元素样式时，更改其class属性是性能最高的方法；</p></li><li><p>尽量用 transform 来做形变和位移。</p></li></ol></details><ol start="3"><li>垃圾回收机制?老生代，新生代区别？常见方法以及适用对象</li></ol><details class="custom-container details"><summary>Details</summary><p><strong>什么是内存泄漏？</strong><br> 程序的运行需要内存，当程序提出要求，操作系统就会供给内存。对于不再用到的内存，没有及时释放，就叫做内存泄漏。 对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 本质上讲，内存泄漏就是由于疏忽或错误造成程序未能释放那些不再使用的内存，照成内存的浪费。<br><strong>什么是垃圾回收机制?</strong> JavaScript，就是找出那些不再继续使用的值，然后释放其占用的内存。 不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在， 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。 最常见的垃圾回收方式有两种：<br><strong>1.标记清除：</strong> 原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p><ul><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记，离开环境的变量以及被环境中的变量引用的变量的标记。</li><li>再被加上离开环境标记的会被视为准备删除的变量。</li><li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li></ul><p><strong>2.引用计数</strong> 原理：跟踪记录每个值被引用的次数。</p><ul><li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。</li><li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。</li><li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。</li><li>当引用次数变成0时，说明没办法访问这个值了。</li><li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 （注意：当循环引用的时候就会释放不掉内存。） <strong>如何观察内存泄漏？</strong></li></ul><ol><li>可以浏览器查看内存占用。</li><li>通过命令行，命令行可以使用 Node process.memoryUsage提供的方法。process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。（判断内存泄漏，以heapUsed字段为准。）</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { </span>
<span class="token comment">// rss: 27709440,</span>
<span class="token comment">// heapTotal: 5685248,</span>
<span class="token comment">// heapUsed: 3449392,</span>
<span class="token comment">// external: 8772 </span>
<span class="token comment">// }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该对象包含四个字段，单位是字节，含义如下: rss（resident set size）：所有内存占用，包括指令区和堆栈。<br> heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。<br> heapUsed：用到的堆的部分。<br> external： V8 引擎内部的 C++ 对象占用的内存。<br> 判断内存泄漏，以heapUsed字段为准。</p><p><strong>常见的内存泄露案例</strong></p><ol><li>意外的全局变量</li><li>被遗忘的定时器和回调函数</li></ol><p><strong>如何避免内存泄漏</strong>. 垃圾回收机制的常用方式是标记清除和引用计数。 记住一个原则：不用的东西，及时归还。</p><p>减少不必要的全局变量，使用严格模式避免意外创建全局变量。 在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</p></details><ol start="4"><li>HTTPS</li></ol><details class="custom-container details"><summary>Details</summary><p><strong>什么是HTTPS</strong>HTTPS以安全为目标的HTTP通道，简单讲是HTTP的安全版，HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL <strong>Https的作用</strong></p><ul><li>内容加密：建立一个信息安全通道，来保证数据传输的安全</li><li>身份认证确：认网站的真实性</li><li>数据完整性：防止内容被第三方冒充或者篡改</li></ul><p><strong>Https的劣势：</strong> 对数据进行加解密决定了它比http慢</p><p>需要进行非对称的加解密，且需要三次握手。首次连接比较慢点，当然现在也有很多的优化。</p><p>出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。 IE只要http头允许就可以缓存https内容，缓存策略与是否使用HTTPS协议无关。</p></details><ol start="5"><li>性能优化的方法</li></ol><details class="custom-container details"><summary>Details</summary><ol><li>减少HTTP请求</li></ol><ul><li>打包合理的合并JS，CSS文件</li><li>合理设置数据缓存，更新频率比较低的静态资源缓存在浏览器</li><li>缓存更新使用逐量更新的方法</li></ul><ol start="2"><li>减少传输文件的体积，在服务器端对引入文件进行压缩，浏览器对文件解压使用，服务器资源不足的情况下要权衡考</li><li>对图片使用懒加载</li><li>CSS放在页面最上部，javascript放在页面最下面，或异步加载JS</li><li>组件懒加载和预加载</li><li>减少cookie传输，可考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie</li><li>公共的插件代码包使用CDN引入，CDN缓存静态资源</li><li>Javascript代码优化 <ul><li>减少作用域链查找,访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。</li><li>数据访问,对对象属性以及数组的访问需要更大的开销,将数据放入局部变量</li><li>使用”+”号来拼接字符串效率是比较低的，每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。高效的做法是使用数组的 join方法，需要拼接的字符串较多的时候可以考虑</li></ul></li><li>CSS选择符优化</li></ol></details><ol start="6"><li>如何监控页面性能</li></ol><details class="custom-container details"><summary>Details</summary><p>为什么要监控页面性能？一个页面性能差的话会大大影响用户体验，性能优化是一项复杂而挑战的事情，需要明确的优化方向和具体的优化手段才能快速落地取效，所以我们需要一个性能监控系统，持续监控和预警页面性能的状况，并且在发现瓶颈的时候指导优化工作。</p></details>`,10),b={start:"7"},f=l("br",null,null,-1),D={href:"https://cloud.tencent.com/developer/article/1650831",target:"_blank",rel:"noopener noreferrer"},P=l("br",null,null,-1),H={href:"https://blog.csdn.net/xuchuangqi/article/details/51673947",target:"_blank",rel:"noopener noreferrer"},x=l("br",null,null,-1),C={href:"https://cloud.tencent.com/developer/article/1650831",target:"_blank",rel:"noopener noreferrer"},w=t('<details class="custom-container details"><summary>Details</summary><p>web监控打开调试工具的performance监控命令； performance.navigation: 页面是加载还是刷新、发生了多少次重定向 performance.timing: 页面加载的各阶段时长 performance.memory：基本内存使用情况，Chrome 添加的一个非标准扩展 performance.timeorigin: 性能测量开始时的时间的高精度时间戳 performance.getEntries()获取到所有的 performance 实体对象，通过 getEntriesByName 和 getEntriesByType 方法可对所有的 performance 实体对象 进行过滤，返回特定类型的实体。 performance.getEntriesByName() performance.getEntriesByType() performance.mark() performance.clearMarks() performance.measure() performance.clearMeasures() performance.now() ...</p><p>mark 方法 和 measure 方法的结合可打点计时，获取某个函数执行耗时等。</p></details><ol><li>数据库？ 数据结构与算法、计算机、操作系统有学过吗？能说说你常用哪些结构和算法吗？有什么明显区别吗？</li></ol><details class="custom-container details"><summary>Details</summary><p><strong>数据库</strong>：【待补充】</p><p><strong>常见的数据结构</strong>：数组，链表，栈，队列，树，图。</p><p><strong>常见算法</strong>：</p><ul><li>排序算法：冒泡，归并，插入，快速</li><li>递归，回塑</li><li>搜索算法：广度优先，深度优先，动态规划，二分法，贪婪算法</li></ul></details><ol start="9"><li>HTTP、 TCP了解吗？能详细说说吗</li></ol><details class="custom-container details"><summary>Details</summary><ul><li>TCP是底层通讯协议，定义的是数据传输和连接方式的规范</li><li>HTTP是应用层协议，定义的是传输数据的内容的规范</li><li>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP</li><li>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</li><li>在HTTP 1.0每次连接只能发送一个请求</li><li>在HTTP 1.1每次求请求支持同时发送多个请求</li><li>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</li></ul></details><ol start="10"><li>http请求过程以及http1和http2.0的区别 【待补充】</li></ol><details class="custom-container details"><summary>Details</summary><p>HTTP 1.1 ：使用基于文本格式</p><p>HTTP 2.0 ：使用二进制格式</p></details><ol start="11"><li>https过程</li></ol><details class="custom-container details"><summary>Details</summary><p>【待补充】</p></details><ol start="12"><li>Vite 原理</li></ol><details class="custom-container details"><summary>Details</summary><p>vite 主要解决了传统bundle-base服务器在开发时遇到的两个问题：</p><ol><li>服务器启动速度慢，而且其启动时间是跟应用规模成正比的。</li><li>在更新时，即便使用了HMR，但是其热更新的时间仍是会随着应用规模的增长而直线下降。</li><li>它解决的是开发的时候的效率问题,对于生产环境则是交给了Rollup</li><li>对ts、jsx、css等开箱即用，无需配置。</li><li>对于库开发者也是可以通过简单的配置即可打包输出多种格式的包。</li><li>开发和生产共享了rollup的插件接口，大部分的rollup插件可以在vite上使用。</li><li>类型化配置，配置文件可以使用ts，具有配置类型提示。</li></ol></details><ol start="13"><li>vue2响应式原理</li></ol>',12),M={class:"custom-container details"},O=l("summary",null,"Details",-1),j={href:"https://juejin.cn/post/7044505066392420388",target:"_blank",rel:"noopener noreferrer"},N=l("blockquote",null,[l("p",null,"在JS中侦测一个对象的变化，可以使用Object.defineProperty和Proxy， 而由于ES6在浏览器的支持度并不理想(vue2.0在2016年10月1日发布)， 所以在vue2版本中还是选择使用Object.defineProperty来实现。")],-1),V=l("p",null,"由于 JavaScript 的限制，Vue 不能检测数组和对象的变化",-1),E=l("p",null,[s("数据响应式三个比较重要的模块： Observer：做数据劫持，收集依赖 Dep：集中管理依赖 Watcher:观测者 "),l("strong",null,"Observer， Dep, watcher之间的关系")],-1),L=l("ul",null,[l("li",null,"Data通过Observer转换成了getter/setter的形式来追踪变化。"),l("li",null,"当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖管理（Dep）中。"),l("li",null,"当数据发生了变化时，会触发setter，从而向Dep中的依赖（Watcher）发送通知。"),l("li",null,"Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。")],-1),I={start:"14"},R={href:"https://juejin.cn/post/7002854148190240781",target:"_blank",rel:"noopener noreferrer"},J=t('<details class="custom-container details"><summary>Details</summary><ol><li>XSS：跨站脚本攻击</li><li>CSRF：跨站请求伪造</li><li>iframe 安全</li><li>错误的内容推断</li><li>第三方依赖包</li><li>HTTPS</li><li>本地存储数据</li><li>静态资源完整性校验</li><li>网络劫持</li><li>中间人攻击：</li><li>sql 注入</li><li>前端数据安全：</li></ol></details><ol start="15"><li>代码评价标准？</li></ol><details class="custom-container details"><summary>Details</summary><ol><li>可维护性（maintainability） 所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新bug的风险，并且需要花费很长的时间才能完成，维护代码的时间远远大于编写代码的时间 代码的可读性、简洁、可拓展， 代码可维护性跟很多因素有关：代码量的多少、业务的复杂程度、团队成员的开发水平、注释和文档是否全面、利用到的技术的复杂程度、</li></ol><p>不同水平的人对于同一份代码的维护能力并不是相同的（代码质量的评价有很强的主观性）</p><ol start="2"><li>可读性（readability）</li></ol><p>软件设计大师Martin Fowler曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.” 代码的可读性在非常大程度上会影响代码的可维护性。 代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</p><ol start="3"><li><p>可扩展性（extensibility） 表示我们的代码应对未来需求变化的能力， 需要修改原有的代码，只要在扩展点上添加新的代码即可 “对修改关闭，对扩展开放”这条设计原则</p></li><li><p>灵活性（flexibility）（易扩展、易复用或者易用）</p></li></ol><ul><li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li><li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li></ul><ol start="5"><li><p>简洁性（simplicity） 简单、清晰放到首位 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。 符合 KISS 原则</p></li><li><p>可复用性（reusability） 尽量减少重复代码的编写，</p></li></ol><ul><li>当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性</li><li>当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；</li><li>当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性</li></ul><ol start="7"><li>可测试性（testability） 比较难写单元测试，那基本上就能说明代码设计得有问题</li></ol><p>可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准</p><p><strong>如何才能写出高质量的代码？</strong></p><p>问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。 我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等。</p><ol><li>面向对象中的继承、多态能让我们写出可复用的代码；</li><li>编码规范能让我们写出可读性好的代码；</li><li>设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；</li><li>设计模式可以让我们写出易扩展的代码；</li><li>持续重构可以时刻保持代码的可维护性等等</li></ol></details><p>vite做了哪些优化</p>',4),B={class:"custom-container details"},U=l("summary",null,"Details",-1),W=l("ol",null,[l("li",null,"启动阶段跳过编译，大大缩短了启动时长"),l("li",null,"vite只做了两件事，一是启动了一个用于承载资源服务的 service；二是使用 esbuild 预构建 npm 依赖包。"),l("li",null,"直到浏览器以 http 方式发来 ESM 规范的模块请求时，Vite 才开始“「按需编译」”被请求的模块。")],-1),q=l("p",null,"Vite 还有很多值得一提的性能优化，整体梳理一下：",-1),z=l("p",null,"「打包」 不是目的，「运行」 才是，2021年了，能够交给浏览器做的事情就交给浏览器吧",-1),Z=l("p",null,"我个人对 Vite 的态度：短期保持观望，长期非常看好。",-1),X=l("ul",null,[l("li",null,"预编译：npm 包这类基本不会变化的模块，使用 Esbuild 在 「预构建」 阶段先打包整理好，减少 http 请求数"),l("li",null,"按需编译：用户代码这一类频繁变动的模块，直到被使用时才会执行编译操作"),l("li",null,"客户端强缓存：请求过的模块会被以 http 头 max-age=31536000,immutable 设置为强缓存，如果模块发生变化则用附加的版本 query 使其失效"),l("li",null,"产物优化：相比于 Webpack ，Vite 直接锚定高版本浏览器，不需要在 build 产物中插入过多运行时与模板代码"),l("li",null,"内置更好的分包实现：不需要用户干预，默认启用一系列智能分包规则，尽可能减少模块的重复打包"),l("li",null,"更好的静态资源处理：Vite 尽量避免直接处理静态资源，而是选择遵循 ESM 方式提供服务，例如引入图片 import img from 'xxx.png' 语句，执行后 img 变量只是一个路径字符串。")],-1),A=l("p",null,"可以看出，Vite 的快是全方位的，从 Dev 到 Build，从 npm 包到项目源码，再到静态资源处理都在 ESM 规则框架下尽可能地实现各种优化措施，理论性能急剧提升。",-1),F={href:"https://juejin.cn/post/7090201071464742949",target:"_blank",rel:"noopener noreferrer"},K=t(`<details class="custom-container details"><summary>Details</summary><p>简述一下整个预构建流程：</p><ol><li>首先会去查找缓存目录（默认是 node_modules/.vite）下的 _metadata.json 文件；然后找到当前项目依赖信息（xxx-lock 文件）拼接上部分配置后做哈希编码，最后对比缓存目录下的 hash 值是否与编码后的 hash 值一致，一致并且没有开启 force 就直接返回预构建信息，结束整个流程；</li><li>如果开启了 force 或者项目依赖有变化的情况，先保证缓存目录干净（node_modules/.vite 下没有多余文件），在 node_modules/.vite/package.json 文件写入 type: module 配置。这就是为什么 vite 会将预构建产物视为 ESM 的原因。</li><li>分析入口，依次查看是否存在 optimizeDeps.entries、build.rollupOptions.input、*.html，匹配到就通过 dev-scan 的插件寻找需要预构建的依赖，输出 deps 和 missing，并重新做 hash 编码；</li><li>最后使用 es-module-lexer 对 deps 模块进行模块化分析，拿到分析结果做预构建。构建结果将合并内部模块、转换 CommonJS 依赖。最后更新 data.optimizeDeps 并将结果写入到缓存文件。</li></ol></details><p>webpack里面less怎么转化，less loader有什么用</p><details class="custom-container details"><summary>Details</summary><p>安装<code>css-loader</code> <code>style-loader</code> <code>less-loader</code>,配置<code>.less</code>文件使用loader</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
    <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;style-loader&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;css-loader&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;less-loader&#39;</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认webpack只支持js模块，如果我们引入了weback不支持的模块，则会在打包时报错，这时就需要loader把模块翻译成webpack能识别的模块</p></details><p>还用过什么打包工具吗</p><details class="custom-container details"><summary>Details</summary><p>gulp, grunt, webpack, vite</p></details><ol start="11"><li><p>Linux了解吗 【待补充，先学操作系统】</p></li><li><p>Java/c++你用过吗？</p></li></ol><details class="custom-container details"><summary>Details</summary><p>最近有参与一个Java项目的开发，负责部分接口和业务。</p></details><details class="custom-container details"><summary>Details</summary></details><details class="custom-container details"><summary>Details</summary></details>`,9);function G(Q,Y){const i=n("ExternalLinkIcon"),a=n("Mermaid");return r(),p("div",null,[u,d,l("details",m,[h,l("ol",null,[_,g,y,l("li",null,[s("某些服务器会做永久重定向响应 "),l("ol",null,[T,l("li",null,[s("重定向的作用：重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力，重定向也可将多个域名的访问，集中到一个站点；"),l("a",k,[s("由于baidu.com"),e(i)]),s("，www.baidu.com会被搜索引擎认为是两个网站，造成每个的连接数都活减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名")])])]),v])]),S,l("ol",b,[l("li",null,[s("如何监控 js 脚本性能, 从 Web 端和 Node 端分别讲."),f,l("a",D,[s("web性能监控"),e(i)]),s("."),P,l("a",H,[s("JS 监控页面刷新,关闭 事件的方法"),e(i)]),s("."),x,l("a",C,[s("web性能监控"),e(i)]),s(".")])]),w,l("details",M,[O,l("p",null,[l("a",j,[s("双向数据绑定原理"),e(i)])]),N,V,E,L]),l("ol",I,[l("li",null,[l("a",R,[s("攻击"),e(i)])])]),J,l("details",B,[U,W,q,e(a,{id:"mermaid-930",code:"eNpVjktOAkEUReesokamSGQLJvJRVFCDK0BEIUBr+MQpKCgtLWAwiMpfEzQoHyOQNLRspl9V9S6sSjtx9nLz7rnnOHp6Hgj540nk8VkQWsck3WOXGimV4fbaarOtITsmimzU03RRZcM7K1pBDqyrPSq/i9uJ9fkLbWcgfwVKDgZNWhyJ3IUhN9XnVSuH2jlmAwcTh6lw9AgZ3SxpZmGuIukshvSfBptUeVWUNjHr9tlwRsYX5GH6b5ZjHBzjxkSu8G++DqPSKty0maaxZZl1FPL8Dcu+wGxh8tUhdTmekqSwdIKS4VhQ5Nt/OXnrUDlveguwk4N3uO8YyorpwzVAq+hanRY+aL9An7KBUEqKCIgHC23TzXQRqRcb8xobvCbjwaAtEfJH+K5Auzh6F8OgS/Iz2h/CQqWLCnzWRGcPG41Hks6wSZaoZX1RA6Uq8n0MLVVXi1Bs0fuW68DL591en9XyC5Ep3BI="}),e(a,{id:"mermaid-931",code:"eNpLy8kvT85ILCpRCHHiUlBw1Hja1vp87zpNXV07BScN5+Dgl4tani5peT6hTVNBTcFZwyPE1wdFyEXDwzcIxHDVeLqn6dnapU+7FrzYuxck4qbxcveMF+uWPO1oe9rTChJxh4okZ5TmZStkJBZnvGzvfTpx79MJvZoKXABRWT7n"}),z,Z,X,A]),l("p",null,[l("a",F,[s("vite 构建流程"),e(i)])]),K])}const sl=o(c,[["render",G],["__file","level3.html.vue"]]);export{sl as default};
