import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as o,a as e,b as i,d as l,f as s,r as n}from"./app.76aaae20.js";const c={},h={id:"promise",tabindex:"-1"},d=e("a",{class:"header-anchor",href:"#promise","aria-hidden":"true"},"#",-1),m={href:"https://blog.csdn.net/weixin_41817034/article/details/80492315",target:"_blank",rel:"noopener noreferrer"},p={href:"https://blog.csdn.net/weixin_41817034/article/details/80492315",target:"_blank",rel:"noopener noreferrer"},_=s('<h2 id="什么是promise" tabindex="-1"><a class="header-anchor" href="#什么是promise" aria-hidden="true">#</a> 什么是Promise</h2><ul><li>Promise 是异步编程的一种解决方案，</li><li>它是一个对象，从它可以获取异步操作的消息，</li><li>它是承诺，承诺它过一段时间会给你一个结果</li><li>是一个构造函数，接收一个参数：函数,函数需要传入两个参数reject、resolve <ul><li>resolve ：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul></li><li>原型上有then、catch方法 <ul><li>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调</li><li>catch 和then的第二个参数一样，用来指定reject的回调，同时有try/catch语句有相同的功能，可以接受then中抛出的异常</li></ul></li><li>all接收一个数组参数,里面的值最终都算返回Promise对象,所有异步操作执行完后才执行回调</li><li>race谁跑的快，以谁为准执行,可以回调给某个异步请求设置超时时间</li></ul><h2 id="promise的三种状态-状态一旦改变-就不会再变" tabindex="-1"><a class="header-anchor" href="#promise的三种状态-状态一旦改变-就不会再变" aria-hidden="true">#</a> promise的三种状态（状态一旦改变，就不会再变）：</h2><ul><li>pending(等待态)</li><li>fulfiled(成功态)</li><li>rejected(失败态)</li><li></li></ul><h2 id="promise解决什么问题" tabindex="-1"><a class="header-anchor" href="#promise解决什么问题" aria-hidden="true">#</a> promise解决什么问题：</h2><ul><li>解决异步的问题</li><li>解决回调地狱问题，第一个函数的输出就是第二个函数的输入</li><li>promise可以支持多个并发的请求</li><li></li></ul><h2 id="promise的三个常用的方法" tabindex="-1"><a class="header-anchor" href="#promise的三个常用的方法" aria-hidden="true">#</a> Promise的三个常用的方法</h2>',7);function u(f,x){const r=n("ExternalLinkIcon");return t(),o("div",null,[e("h1",h,[d,i(),e("a",m,[i("Promise"),l(r)])]),e("p",null,[e("a",p,[i("Promise"),l(r)])]),_])}const v=a(c,[["render",u],["__file","promise.html.vue"]]);export{v as default};
